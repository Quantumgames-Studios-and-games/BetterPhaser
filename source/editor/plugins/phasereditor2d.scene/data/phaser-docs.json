{
  "Phaser.GameObjects.Image": "An Image Game Object.\r\rAn Image is a light-weight Game Object useful for the display of static images in your game,\rsuch as logos, backgrounds, scenery or other non-animated elements. Images can have input\revents and physics bodies, or be tweened, tinted or scrolled. The main difference between an\rImage and a Sprite is that you cannot animate an Image as they do not have the Animation component.",
  "Phaser.GameObjects.Sprite": "A Sprite Game Object.\r\rA Sprite Game Object is used for the display of both static and animated images in your game.\rSprites can have input events and physics bodies. They can also be tweened, tinted, scrolled\rand animated.\r\rThe main difference between a Sprite and an Image Game Object is that you cannot animate Images.\rAs such, Sprites take a fraction longer to process and have a larger API footprint due to the Animation\rComponent. If you do not require animation then you can safely use Images to replace Sprites in all cases.",
  "Phaser.GameObjects.Container": "A Container Game Object.\r\rA Container, as the name implies, can 'contain' other types of Game Object.\rWhen a Game Object is added to a Container, the Container becomes responsible for the rendering of it.\rBy default it will be removed from the Display List and instead added to the Containers own internal list.\r\rThe position of the Game Object automatically becomes relative to the position of the Container.\r\rThe origin of a Container is 0x0 (in local space) and that cannot be changed. The children you add to the\rContainer should be positioned with this value in mind. I.e. you should treat 0x0 as being the center of\rthe Container, and position children positively and negative around it as required.\r\rWhen the Container is rendered, all of its children are rendered as well, in the order in which they exist\rwithin the Container. Container children can be repositioned using methods such as `MoveUp`, `MoveDown` and `SendToBack`.\r\rIf you modify a transform property of the Container, such as `Container.x` or `Container.rotation` then it will\rautomatically influence all children as well.\r\rContainers can include other Containers for deeply nested transforms.\r\rContainers can have masks set on them and can be used as a mask too. However, Container children cannot be masked.\rThe masks do not 'stack up'. Only a Container on the root of the display list will use its mask.\r\rContainers can be enabled for input. Because they do not have a texture you need to provide a shape for them\rto use as their hit area. Container children can also be enabled for input, independent of the Container.\r\rIf input enabling a _child_ you should not set both the `origin` and a **negative** scale factor on the child,\ror the input area will become misaligned.\r\rContainers can be given a physics body for either Arcade Physics, Impact Physics or Matter Physics. However,\rif Container _children_ are enabled for physics you may get unexpected results, such as offset bodies,\rif the Container itself, or any of its ancestors, is positioned anywhere other than at 0 x 0. Container children\rwith physics do not factor in the Container due to the excessive extra calculations needed. Please structure\ryour game to work around this.\r\rIt's important to understand the impact of using Containers. They add additional processing overhead into\revery one of their children. The deeper you nest them, the more the cost escalates. This is especially true\rfor input events. You also loose the ability to set the display depth of Container children in the same\rflexible manner as those not within them. In short, don't use them for the sake of it. You pay a small cost\revery time you create one, try to structure your game around avoiding that where possible.",
  "Phaser.GameObjects.Components.Transform.x": "The x position of this Game Object.",
  "Phaser.GameObjects.Components.Transform.y": "The y position of this Game Object.",
  "Phaser.GameObjects.Components.Transform.setPosition": "Sets the position of this Game Object.",
  "Phaser.GameObjects.Components.Transform.scaleX": "The horizontal scale of this Game Object.",
  "Phaser.GameObjects.Components.Transform.scaleY": "The vertical scale of this Game Object.",
  "Phaser.GameObjects.Components.Transform.angle": "The angle of this Game Object as expressed in degrees.\r\rPhaser uses a right-hand clockwise rotation system, where 0 is right, 90 is down, 180/-180 is left\rand -90 is up.\r\rIf you prefer to work in radians, see the `rotation` property instead.",
  "Phaser.GameObjects.Components.Origin.originX": "The horizontal origin of this Game Object.\rThe origin maps the relationship between the size and position of the Game Object.\rThe default value is 0.5, meaning all Game Objects are positioned based on their center.\rSetting the value to 0 means the position now relates to the left of the Game Object.",
  "Phaser.GameObjects.Components.Origin.originY": "The vertical origin of this Game Object.\rThe origin maps the relationship between the size and position of the Game Object.\rThe default value is 0.5, meaning all Game Objects are positioned based on their center.\rSetting the value to 0 means the position now relates to the top of the Game Object.",
  "Phaser.GameObjects.Components.Origin.setOrigin": "Sets the origin of this Game Object.\r\rThe values are given in the range 0 to 1.",
  "Phaser.GameObjects.Components.Alpha.alpha": "The alpha value of the Game Object.\r\rThis is a global value, impacting the entire Game Object, not just a region of it.",
  "Phaser.GameObjects.Components.Alpha.alphaTopLeft": "The alpha value starting from the top-left of the Game Object.\rThis value is interpolated from the corner to the center of the Game Object.",
  "Phaser.GameObjects.Components.Alpha.alphaTopRight": "The alpha value starting from the top-right of the Game Object.\rThis value is interpolated from the corner to the center of the Game Object.",
  "Phaser.GameObjects.Components.Alpha.alphaBottomLeft": "The alpha value starting from the bottom-left of the Game Object.\rThis value is interpolated from the corner to the center of the Game Object.",
  "Phaser.GameObjects.Components.Alpha.alphaBottomRight": "The alpha value starting from the bottom-right of the Game Object.\rThis value is interpolated from the corner to the center of the Game Object.",
  "Phaser.GameObjects.Components.Flip.flipX": "The horizontally flipped state of the Game Object.\r\rA Game Object that is flipped horizontally will render inversed on the horizontal axis.\rFlipping always takes place from the middle of the texture and does not impact the scale value.\rIf this Game Object has a physics body, it will not change the body. This is a rendering toggle only.",
  "Phaser.GameObjects.Components.Flip.flipY": "The vertically flipped state of the Game Object.\r\rA Game Object that is flipped vertically will render inversed on the vertical axis (i.e. upside down)\rFlipping always takes place from the middle of the texture and does not impact the scale value.\rIf this Game Object has a physics body, it will not change the body. This is a rendering toggle only.",
  "Phaser.GameObjects.Components.Visible.visible": "The visible state of the Game Object.\r\rAn invisible Game Object will skip rendering, but will still process update logic.",
  "Phaser.GameObjects.Components.Tint.tint": "The tint value being applied to the whole of the Game Object.\rThis property is a setter-only. Use the properties `tintTopLeft` etc to read the current tint value.",
  "Phaser.GameObjects.Components.Tint.tintFill": "The tint fill mode.\r\r`false` = An additive tint (the default), where vertices colors are blended with the texture.\r`true` = A fill tint, where the vertices colors replace the texture, but respects texture alpha.",
  "Phaser.GameObjects.Components.Tint.tintTopLeft": "The tint value being applied to the top-left vertice of the Game Object.\rThis value is interpolated from the corner to the center of the Game Object.\rThe value should be set as a hex number, i.e. 0xff0000 for red, or 0xff00ff for purple.",
  "Phaser.GameObjects.Components.Tint.tintTopRight": "The tint value being applied to the top-right vertice of the Game Object.\rThis value is interpolated from the corner to the center of the Game Object.\rThe value should be set as a hex number, i.e. 0xff0000 for red, or 0xff00ff for purple.",
  "Phaser.GameObjects.Components.Tint.tintBottomLeft": "The tint value being applied to the bottom-left vertice of the Game Object.\rThis value is interpolated from the corner to the center of the Game Object.\rThe value should be set as a hex number, i.e. 0xff0000 for red, or 0xff00ff for purple.",
  "Phaser.GameObjects.Components.Tint.tintBottomRight": "The tint value being applied to the bottom-right vertice of the Game Object.\rThis value is interpolated from the corner to the center of the Game Object.\rThe value should be set as a hex number, i.e. 0xff0000 for red, or 0xff00ff for purple.",
  "Phaser.GameObjects.TileSprite": "A TileSprite is a Sprite that has a repeating texture.\r\rThe texture can be scrolled and scaled independently of the TileSprite itself. Textures will automatically wrap and\rare designed so that you can create game backdrops using seamless textures as a source.\r\rYou shouldn't ever create a TileSprite any larger than your actual canvas size. If you want to create a large repeating background\rthat scrolls across the whole map of your game, then you create a TileSprite that fits the canvas size and then use the `tilePosition`\rproperty to scroll the texture as the player moves. If you create a TileSprite that is thousands of pixels in size then it will\rconsume huge amounts of memory and cause performance issues. Remember: use `tilePosition` to scroll your texture and `tileScale` to\radjust the scale of the texture - don't resize the sprite itself or make it larger than it needs.\r\rAn important note about Tile Sprites and NPOT textures: Internally, TileSprite textures use GL_REPEAT to provide\rseamless repeating of the textures. This, combined with the way in which the textures are handled in WebGL, means\rthey need to be POT (power-of-two) sizes in order to wrap. If you provide a NPOT (non power-of-two) texture to a\rTileSprite it will generate a POT sized canvas and draw your texture to it, scaled up to the POT size. It's then\rscaled back down again during rendering to the original dimensions. While this works, in that it allows you to use\rany size texture for a Tile Sprite, it does mean that NPOT textures are going to appear anti-aliased when rendered,\rdue to the interpolation that took place when it was resized into a POT texture. This is especially visible in\rpixel art graphics. If you notice it and it becomes an issue, the only way to avoid it is to ensure that you\rprovide POT textures for Tile Sprites.",
  "Phaser.GameObjects.Components.ComputedSize.width": "The native (un-scaled) width of this Game Object.\r\rChanging this value will not change the size that the Game Object is rendered in-game.\rFor that you need to either set the scale of the Game Object (`setScale`) or use\rthe `displayWidth` property.",
  "Phaser.GameObjects.Components.ComputedSize.height": "The native (un-scaled) height of this Game Object.\r\rChanging this value will not change the size that the Game Object is rendered in-game.\rFor that you need to either set the scale of the Game Object (`setScale`) or use\rthe `displayHeight` property.",
  "Phaser.GameObjects.Components.ComputedSize.setSize": "Sets the internal size of this Game Object, as used for frame or physics body creation.\r\rThis will not change the size that the Game Object is rendered in-game.\rFor that you need to either set the scale of the Game Object (`setScale`) or call the\r`setDisplaySize` method, which is the same thing as changing the scale but allows you\rto do so by giving pixel values.\r\rIf you have enabled this Game Object for input, changing the size will _not_ change the\rsize of the hit area. To do this you should adjust the `input.hitArea` object directly.",
  "Phaser.GameObjects.TileSprite.tilePositionX": "The horizontal scroll position of the Tile Sprite.",
  "Phaser.GameObjects.TileSprite.tilePositionY": "The vertical scroll position of the Tile Sprite.",
  "Phaser.GameObjects.TileSprite.setTilePosition": "Sets {@link Phaser.GameObjects.TileSprite#tilePositionX} and {@link Phaser.GameObjects.TileSprite#tilePositionY}.",
  "Phaser.GameObjects.TileSprite.tileScaleX": "The horizontal scale of the Tile Sprite texture.",
  "Phaser.GameObjects.TileSprite.tileScaleY": "The vertical scale of the Tile Sprite texture.",
  "Phaser.GameObjects.TileSprite.setTileScale": "Sets {@link Phaser.GameObjects.TileSprite#tileScaleX} and {@link Phaser.GameObjects.TileSprite#tileScaleY}.",
  "Phaser.GameObjects.GameObject.parentContainer": "The parent Container of this Game Object, if it has one.",
  "Phaser.GameObjects.Text": "A Text Game Object.\r\rText objects work by creating their own internal hidden Canvas and then renders text to it using\rthe standard Canvas `fillText` API. It then creates a texture from this canvas which is rendered\rto your game during the render pass.\r\rBecause it uses the Canvas API you can take advantage of all the features this offers, such as\rapplying gradient fills to the text, or strokes, shadows and more. You can also use custom fonts\rloaded externally, such as Google or TypeKit Web fonts.\r\r**Important:** The font name must be quoted if it contains certain combinations of digits or\rspecial characters, either when creating the Text object, or when setting the font via `setFont`\ror `setFontFamily`, e.g.:\r\r```javascript\rthis.add.text(0, 0, 'Hello World', { fontFamily: 'Georgia, \"Goudy Bookletter 1911\", Times, serif' });\r```\r\r```javascript\rthis.add.text(0, 0, 'Hello World', { font: '\"Press Start 2P\"' });\r```\r\rYou can only display fonts that are currently loaded and available to the browser: therefore fonts must\rbe pre-loaded. Phaser does not do ths for you, so you will require the use of a 3rd party font loader,\ror have the fonts ready available in the CSS on the page in which your Phaser game resides.\r\rSee {@link http://www.jordanm.co.uk/tinytype this compatibility table} for the available default fonts\racross mobile browsers.\r\rA note on performance: Every time the contents of a Text object changes, i.e. changing the text being\rdisplayed, or the style of the text, it needs to remake the Text canvas, and if on WebGL, re-upload the\rnew texture to the GPU. This can be an expensive operation if used often, or with large quantities of\rText objects in your game. If you run into performance issues you would be better off using Bitmap Text\rinstead, as it benefits from batching and avoids expensive Canvas API calls.",
  "Phaser.Types.GameObjects.Text.TextStyle.fixedWidth": "Force the Text object to have the exact width specified in this property. Leave as zero for it to change accordingly to content.",
  "Phaser.Types.GameObjects.Text.TextStyle.fixedHeight": "Force the Text object to have the exact height specified in this property. Leave as zero for it to change accordingly to content.",
  "Phaser.GameObjects.TextStyle.setFixedSize": "Set a fixed width and height for the text.\r\rPass in `0` for either of these parameters to disable fixed width or height respectively.",
  "Phaser.GameObjects.Text.setPadding": "Set the text padding.\r\r'left' can be an object.\r\rIf only 'left' and 'top' are given they are treated as 'x' and 'y'.",
  "Phaser.Types.GameObjects.Text.TextPadding.left": "The amount of padding added to the left of the Text object.",
  "Phaser.Types.GameObjects.Text.TextPadding.top": "The amount of padding added to the top of the Text object.",
  "Phaser.Types.GameObjects.Text.TextPadding.right": "The amount of padding added to the right of the Text object.",
  "Phaser.Types.GameObjects.Text.TextPadding.bottom": "The amount of padding added to the bottom of the Text object.",
  "Phaser.GameObjects.Text.lineSpacing": "The line spacing value.\rThis value is added to the font height to calculate the overall line height.\rOnly has an effect if this Text object contains multiple lines of text.\r\rIf you update this property directly, instead of using the `setLineSpacing` method, then\rbe sure to call `updateText` after, or you won't see the change reflected in the Text object.",
  "Phaser.GameObjects.Text.setAlign": "Set the alignment of the text in this Text object.\r\rThe argument can be one of: `left`, `right`, `center` or `justify`.\r\rAlignment only works if the Text object has more than one line of text.",
  "Phaser.GameObjects.Text.setFontFamily": "Set the font family.\r\r**Important:** The font name must be quoted if it contains certain combinations of digits or\rspecial characters:\r\r```javascript\rText.setFont('\"Press Start 2P\"');\r```\r\rEqually, if you wish to provide a list of fallback fonts, then you should ensure they are all\rquoted properly, too:\r\r```javascript\rText.setFont('Georgia, \"Goudy Bookletter 1911\", Times, serif');\r```",
  "Phaser.GameObjects.Text.setFontSize": "Set the font size.",
  "Phaser.GameObjects.Text.setFontStyle": "Set the font style.",
  "Phaser.GameObjects.Text.setColor": "Set the text fill color.",
  "Phaser.GameObjects.Text.setStroke(color)": "The stroke color.",
  "Phaser.GameObjects.Text.setStroke(thickness)": "The stroke thickness.",
  "Phaser.GameObjects.Text.setBackgroundColor": "Set the background color.",
  "Phaser.GameObjects.Text.setShadowOffset": "Set the shadow offset.",
  "Phaser.GameObjects.Text.setShadowOffset(x)": "The horizontal shadow offset.",
  "Phaser.GameObjects.Text.setShadowOffset(y)": "The vertical shadow offset.",
  "Phaser.GameObjects.Text.setShadowStroke": "Enable or disable shadow stroke.",
  "Phaser.GameObjects.Text.setShadowFill": "Enable or disable shadow fill.",
  "Phaser.GameObjects.Text.setShadowColor": "Set the shadow color.",
  "Phaser.GameObjects.Text.setShadowBlur": "Set the shadow blur radius.",
  "Phaser.GameObjects.TextStyle.baselineX": "The amount of horizontal padding added to the width of the text when calculating the font metrics.",
  "Phaser.GameObjects.TextStyle.baselineY": "The amount of vertical padding added to the height of the text when calculating the font metrics.",
  "Phaser.GameObjects.Text.setMaxLines": "Set the maximum number of lines to draw.",
  "Phaser.GameObjects.BitmapText": "BitmapText objects work by taking a texture file and an XML or JSON file that describes the font structure.\r\rDuring rendering for each letter of the text is rendered to the display, proportionally spaced out and aligned to\rmatch the font structure.\r\rBitmapText objects are less flexible than Text objects, in that they have less features such as shadows, fills and the ability\rto use Web Fonts, however you trade this flexibility for rendering speed. You can also create visually compelling BitmapTexts by\rprocessing the font texture in an image editor, applying fills and any other effects required.\r\rTo create multi-line text insert \\r, \\n or \\r\\n escape codes into the text string.\r\rTo create a BitmapText data files you need a 3rd party app such as:\r\rBMFont (Windows, free): {@link http://www.angelcode.com/products/bmfont/|http://www.angelcode.com/products/bmfont/}\rGlyph Designer (OS X, commercial): {@link http://www.71squared.com/en/glyphdesigner|http://www.71squared.com/en/glyphdesigner}\rLittera (Web-based, free): {@link http://kvazars.com/littera/|http://kvazars.com/littera/}\r\rFor most use cases it is recommended to use XML. If you wish to use JSON, the formatting should be equal to the result of\rconverting a valid XML file through the popular X2JS library. An online tool for conversion can be found here: {@link http://codebeautify.org/xmltojson|http://codebeautify.org/xmltojson}",
  "Phaser.GameObjects.BitmapText.setFont": "Changes the font this BitmapText is using to render.\r\rThe new texture is loaded and applied to the BitmapText. The existing test, size and alignment are preserved,\runless overridden via the arguments.",
  "Phaser.GameObjects.BitmapText.align": "Controls the alignment of each line of text in this BitmapText object.\r\rOnly has any effect when this BitmapText contains multiple lines of text, split with carriage-returns.\rHas no effect with single-lines of text.\r\rSee the methods `setLeftAlign`, `setCenterAlign` and `setRightAlign`.\r\r0 = Left aligned (default)\r1 = Middle aligned\r2 = Right aligned\r\rThe alignment position is based on the longest line of text.",
  "Phaser.GameObjects.BitmapText.setFontSize": "Set the font size of this Bitmap Text.",
  "Phaser.GameObjects.BitmapText.setLetterSpacing": "Sets the letter spacing between each character of this Bitmap Text.\rCan be a positive value to increase the space, or negative to reduce it.\rSpacing is applied after the kerning values have been set.",
  "Phaser.GameObjects.BitmapText.dropShadowX": "The horizontal offset of the drop shadow.\r\rYou can set this directly, or use `Phaser.GameObjects.BitmapText#setDropShadow`.",
  "Phaser.GameObjects.BitmapText.dropShadowY": "The vertical offset of the drop shadow.\r\rYou can set this directly, or use `Phaser.GameObjects.BitmapText#setDropShadow`.",
  "Phaser.GameObjects.BitmapText.dropShadowColor": "The color of the drop shadow.\r\rYou can set this directly, or use `Phaser.GameObjects.BitmapText#setDropShadow`.",
  "Phaser.GameObjects.BitmapText.dropShadowAlpha": "The alpha value of the drop shadow.\r\rYou can set this directly, or use `Phaser.GameObjects.BitmapText#setDropShadow`.",
  "Phaser.Tilemaps.Tilemap": "A Tilemap is a container for Tilemap data. This isn't a display object, rather, it holds data\rabout the map and allows you to add tilesets and tilemap layers to it. A map can have one or\rmore tilemap layers, which are the display objects that actually render the tiles.\r\rThe Tilemap data can be parsed from a Tiled JSON file, a CSV file or a 2D array. Tiled is a free\rsoftware package specifically for creating tile maps, and is available from:\rhttp://www.mapeditor.org\r\rAs of Phaser 3.50.0 the Tilemap API now supports the following types of map:\r\r1) Orthogonal\r2) Isometric\r3) Hexagonal\r4) Staggered\r\rPrior to this release, only orthogonal maps were supported.\r\rAnother large change in 3.50 was the consolidation of Tilemap Layers. Previously, you created\reither a Static or Dynamic Tilemap Layer. However, as of 3.50 the features of both have been\rmerged and the API simplified, so now there is just the single `TilemapLayer` class.\r\rA Tilemap has handy methods for getting and manipulating the tiles within a layer, allowing\ryou to build or modify the tilemap data at runtime.\r\rNote that all Tilemaps use a base tile size to calculate dimensions from, but that a\rTilemapLayer may have its own unique tile size that overrides this.\r\rAs of Phaser 3.21.0, if your tilemap includes layer groups (a feature of Tiled 1.2.0+) these\rwill be traversed and the following properties will impact children:\r\r- Opacity (blended with parent) and visibility (parent overrides child)\r- Vertical and horizontal offset\r\rThe grouping hierarchy is not preserved and all layers will be flattened into a single array.\r\rGroup layers are parsed during Tilemap construction but are discarded after parsing so dynamic\rlayers will NOT continue to be affected by a parent.\r\rTo avoid duplicate layer names, a layer that is a child of a group layer will have its parent\rgroup name prepended with a '/'.  For example, consider a group called 'ParentGroup' with a\rchild called 'Layer 1'. In the Tilemap object, 'Layer 1' will have the name\r'ParentGroup/Layer 1'.",
  "Phaser.Tilemaps.Tilemap.tileWidth": "The base width of a tile in pixels. Note that individual layers may have a different tile\rwidth.",
  "Phaser.Tilemaps.Tilemap.tileHeight": "The base height of a tile in pixels. Note that individual layers may have a different\rtile height.",
  "Phaser.GameObjects.GameObjectFactory.tilemap(key)": "The key in the Phaser cache that corresponds to the loaded tilemap data.",
  "Phaser.Tilemaps.Tileset": "A Tileset is a combination of an image containing the tiles and a container for data about\reach tile.",
  "Phaser.Tilemaps.Tileset.name": "The name of the Tileset.",
  "Phaser.Tilemaps.Tileset.image": "The cached image that contains the individual tiles. Use setImage to set.",
  "Phaser.Tilemaps.Tileset.tileWidth": "The width of each tile (in pixels). Use setTileSize to change.",
  "Phaser.Tilemaps.Tileset.tileHeight": "The height of each tile (in pixels). Use setTileSize to change.",
  "Phaser.Tilemaps.Tileset.tileMargin": "The margin around the tiles in the sheet (in pixels). Use `setSpacing` to change.",
  "Phaser.Tilemaps.Tileset.tileSpacing": "The spacing between each the tile in the sheet (in pixels). Use `setSpacing` to change.",
  "Phaser.Tilemaps.TilemapLayer": "A Tilemap Layer is a Game Object that renders LayerData from a Tilemap when used in combination\rwith one, or more, Tilesets.",
  "Phaser.Tilemaps.LayerData": "A class for representing data about about a layer in a map. Maps are parsed from CSV, Tiled,\retc. into this format. Tilemap and TilemapLayer objects have a reference\rto this data and use it to look up and perform operations on tiles.",
  "Phaser.Tilemaps.LayerData.name": "The name of the layer, if specified in Tiled.",
  "Phaser.Tilemaps.LayerData.width": "The width of the layer in tiles.",
  "Phaser.Tilemaps.LayerData.height": "The height of the layer in tiles.",
  "Phaser.Tilemaps.LayerData.tileWidth": "The pixel width of the tiles.",
  "Phaser.Tilemaps.LayerData.tileHeight": "The pixel height of the tiles.",
  "Phaser.Tilemaps.LayerData.widthInPixels": "The width in pixels of the entire layer.",
  "Phaser.Tilemaps.LayerData.heightInPixels": "The height in pixels of the entire layer.",
  "Phaser.GameObjects.Shape": "The Shape Game Object is a base class for the various different shapes, such as the Arc, Star or Polygon.\rYou cannot add a Shape directly to your Scene, it is meant as a base for your own custom Shape classes.",
  "Phaser.GameObjects.Shape.isFilled": "Controls if this Shape is filled or not.\rNote that some Shapes do not support being filled (such as Line shapes)",
  "Phaser.GameObjects.Shape.fillColor": "The fill color used by this Shape.",
  "Phaser.GameObjects.Shape.fillAlpha": "The fill alpha value used by this Shape.",
  "Phaser.GameObjects.Shape.isStroked": "Controls if this Shape is stroked or not.\rNote that some Shapes do not support being stroked (such as Iso Box shapes)",
  "Phaser.GameObjects.Shape.strokeColor": "The stroke color used by this Shape.",
  "Phaser.GameObjects.Shape.strokeAlpha": "The stroke alpha value used by this Shape.",
  "Phaser.GameObjects.Shape.lineWidth": "The stroke line width used by this Shape.",
  "Phaser.GameObjects.Rectangle": "The Rectangle Shape is a Game Object that can be added to a Scene, Group or Container. You can\rtreat it like any other Game Object in your game, such as tweening it, scaling it, or enabling\rit for input or physics. It provides a quick and easy way for you to render this shape in your\rgame without using a texture, while still taking advantage of being fully batched in WebGL.\r\rThis shape supports both fill and stroke colors.\r\rYou can change the size of the rectangle by changing the `width` and `height` properties.",
  "Phaser.GameObjects.Ellipse": "The Ellipse Shape is a Game Object that can be added to a Scene, Group or Container. You can\rtreat it like any other Game Object in your game, such as tweening it, scaling it, or enabling\rit for input or physics. It provides a quick and easy way for you to render this shape in your\rgame without using a texture, while still taking advantage of being fully batched in WebGL.\r\rThis shape supports both fill and stroke colors.\r\rWhen it renders it displays an ellipse shape. You can control the width and height of the ellipse.\rIf the width and height match it will render as a circle. If the width is less than the height,\rit will look more like an egg shape.\r\rThe Ellipse shape also has a `smoothness` property and corresponding `setSmoothness` method.\rThis allows you to control how smooth the shape renders in WebGL, by controlling the number of iterations\rthat take place during construction. Increase and decrease the default value for smoother, or more\rjagged, shapes.",
  "Phaser.GameObjects.Ellipse.smoothness": "The smoothness of the ellipse. The number of points used when rendering it.\rIncrease this value for a smoother ellipse, at the cost of more polygons being rendered.",
  "Phaser.GameObjects.Triangle": "The Triangle Shape is a Game Object that can be added to a Scene, Group or Container. You can\rtreat it like any other Game Object in your game, such as tweening it, scaling it, or enabling\rit for input or physics. It provides a quick and easy way for you to render this shape in your\rgame without using a texture, while still taking advantage of being fully batched in WebGL.\r\rThis shape supports both fill and stroke colors.\r\rThe Triangle consists of 3 lines, joining up to form a triangular shape. You can control the\rposition of each point of these lines. The triangle is always closed and cannot have an open\rface. If you require that, consider using a Polygon instead.",
  "Phaser.Geom.Triangle.x1": "`x` coordinate of the first point.",
  "Phaser.Geom.Triangle.y1": "`y` coordinate of the first point.",
  "Phaser.Geom.Triangle.x2": "`x` coordinate of the second point.",
  "Phaser.Geom.Triangle.y2": "`y` coordinate of the second point.",
  "Phaser.Geom.Triangle.x3": "`x` coordinate of the third point.",
  "Phaser.Geom.Triangle.y3": "`y` coordinate of the third point.",
  "Phaser.GameObjects.Layer": "A Layer Game Object.\r\rA Layer is a special type of Game Object that acts as a Display List. You can add any type of Game Object\rto a Layer, just as you would to a Scene. Layers can be used to visually group together 'layers' of Game\rObjects:\r\r```javascript\rconst spaceman = this.add.sprite(150, 300, 'spaceman');\rconst bunny = this.add.sprite(400, 300, 'bunny');\rconst elephant = this.add.sprite(650, 300, 'elephant');\r\rconst layer = this.add.layer();\r\rlayer.add([ spaceman, bunny, elephant ]);\r```\r\rThe 3 sprites in the example above will now be managed by the Layer they were added to. Therefore,\rif you then set `layer.setVisible(false)` they would all vanish from the display.\r\rYou can also control the depth of the Game Objects within the Layer. For example, calling the\r`setDepth` method of a child of a Layer will allow you to adjust the depth of that child _within the\rLayer itself_, rather than the whole Scene. The Layer, too, can have its depth set as well.\r\rThe Layer class also offers many different methods for manipulating the list, such as the\rmethods `moveUp`, `moveDown`, `sendToBack`, `bringToTop` and so on. These allow you to change the\rdisplay list position of the Layers children, causing it to adjust the order in which they are\rrendered. Using `setDepth` on a child allows you to override this.\r\rLayers can have Post FX Pipelines set, which allows you to easily enable a post pipeline across\ra whole range of children, which, depending on the effect, can often be far more efficient that doing so\ron a per-child basis.\r\rLayers have no position or size within the Scene. This means you cannot enable a Layer for\rphysics or input, or change the position, rotation or scale of a Layer. They also have no scroll\rfactor, texture, tint, origin, crop or bounds.\r\rIf you need those kind of features then you should use a Container instead. Containers can be added\rto Layers, but Layers cannot be added to Containers.\r\rHowever, you can set the Alpha, Blend Mode, Depth, Mask and Visible state of a Layer. These settings\rwill impact all children being rendered by the Layer."
}